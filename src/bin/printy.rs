use chrono::Utc;
use clap::{Parser, Subcommand};
use fontdue::layout::{CoordinateSystem, Layout, LayoutSettings, TextStyle};
use printy::printer::{Barcode, Printer, SerialPort, UnixSerialPort};
use raqote::*;
use std::time::Duration;

#[derive(Parser)]
#[clap(author, version, about, long_about = None)]
struct Cli {
    /// Serial port to use
    /// default: /dev/ttyUSB0
    #[clap(short, long, value_parser)]
    serial: String,

    /// Printer firmware version
    #[clap(short, long, value_parser)]
    firmware: Option<u16>,

    /// Baud rate
    #[clap(short, long, value_parser)]
    baudrate: Option<u32>,

    /// Dot Print Time (in microseconds)
    /// default: 20000
    #[clap(long, value_parser)]
    dot_print_time: Option<u64>,

    /// Final line feeds
    /// default: 3
    #[clap(long, value_parser)]
    feed: Option<u8>,

    /// Feed Time (in microseconds)
    /// default: 2100
    #[clap(long, value_parser)]
    dot_feed_time: Option<u64>,

    #[clap(subcommand)]
    command: Commands,
}

#[derive(Subcommand)]
enum Commands {
    TestPage {},
    Print {
        /// Text to print
        text: String,
    },
    Barcode {
        /// Barcode type
        /// default: upc-a
        #[clap(short, long, value_parser)]
        barcode_type: Option<Barcode>,

        /// Barcode to print
        barcode: String,
    },
    Logo {},
}

fn main() {
    let cli = Cli::parse();

    let mut port = serial::open(&cli.serial).unwrap();
    let mut port: UnixSerialPort<19200> = UnixSerialPort::new(port).unwrap();
    let mut printer = Printer::new(port).unwrap();

    println!("{}: Initializing", Utc::now().time().to_string());
    printer.init().unwrap();

    match &cli.command {
        Commands::TestPage {} => {
            println!("{}: Printing test page", Utc::now().to_string());
            printer.cmd_test_page().unwrap();
            printer.wait();
        }
        Commands::Print { text } => {
            println!("{}: Printing text", Utc::now().to_string());
            printer.write(text).unwrap();
            printer.wait();
        }
        Commands::Barcode {
            barcode_type,
            barcode,
        } => {
            println!("{}: Printing barcode", Utc::now().to_string());
            printer
                .print_barcode(barcode, barcode_type.unwrap_or(Barcode::UpcA))
                .unwrap();
            printer.wait();
        }
        Commands::Logo {} => {
            println!("{}: Printing logo", Utc::now().to_string());
            print_logo(&mut printer);
            printer.wait();
        }
    }

    // Read the font data.
    let font = include_bytes!("../../resources/Roboto-Regular.ttf") as &[u8];
    // Parse it into the font type.
    let font = fontdue::Font::from_bytes(font, fontdue::FontSettings::default()).unwrap();
    let fonts = &[font];
    // Rasterize and get the layout metrics for the letter 'g' at 17px.

    let mut layout = Layout::new(CoordinateSystem::PositiveYUp);
    layout.reset(&LayoutSettings {
        max_width: Some(384.0),
        ..LayoutSettings::default()
    });
    layout.append(fonts, &TextStyle::new("Hello ", 35.0, 0));
    layout.append(fonts, &TextStyle::new("World", 40.0, 0));

    println!("lines: {:?}", layout.lines());

    for glyph in layout.glyphs() {
        let (metrics, coverage) = fonts[0].rasterize_config(glyph.key);
        println!("Glyph: {:?}", glyph);
        println!("Metrics: {:?}", metrics);
    }

    let mut dt = DrawTarget::new(384, 400);
    let mut pb = PathBuilder::new();
    pb.move_to(100., 10.);
    pb.cubic_to(150., 40., 175., 0., 200., 10.);
    pb.quad_to(120., 100., 80., 200.);
    pb.quad_to(150., 180., 300., 300.);
    pb.close();
    let path = pb.finish();
    let gradient = Source::new_radial_gradient(
        Gradient {
            stops: vec![
                GradientStop {
                    position: 0.2,
                    color: Color::new(0xff, 0, 0xff, 0),
                },
                GradientStop {
                    position: 0.8,
                    color: Color::new(0xff, 0xff, 0xff, 0xff),
                },
                GradientStop {
                    position: 1.,
                    color: Color::new(0xff, 0xff, 0, 0xff),
                },
            ],
        },
        Point::new(150., 150.),
        128.,
        Spread::Pad,
    );
    dt.fill(&path, &gradient, &DrawOptions::new());
    // BGRA
    // let buf: ImageBuffer<image::Pixel> = ImageBuffer::from_raw(384, 400, dt.get_data_u8()).unwrap();

    // let (metrics, bitmap) = fonts[0].rasterize('g', 128.0);
    // println!("{:?} {:?} {}", metrics, bitmap, bitmap.len());
    // let mut bv: BitVec<u8, Msb0> = bitmap.into_iter().map(|x| x > 128).collect();
    // printer
    //     .print_bitmap(metrics.width, metrics.height, f)
    //     .unwrap();

    // final linefeeds
    printer.cmd_feed(cli.feed.unwrap_or(3)).unwrap();
    printer.wait();
}

fn print_logo<P: SerialPort>(printer: &mut Printer<P>) {
    // 75 * 75
    let adalogo: [u8; 750] = [
        0x00, 0x00, 0x00, 0x00, 0x00, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
        0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xf0, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x03, 0xf8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07,
        0xf8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xf8, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x1f, 0xfc, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1f,
        0xfc, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3f, 0xfc, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x7f, 0xfe, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7f,
        0xfe, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xfe, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x01, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xff,
        0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x07, 0xff, 0xff, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0xff,
        0xff, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0xff, 0xff, 0x80, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x0f, 0xff, 0xff, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xff,
        0xff, 0x80, 0x00, 0x00, 0x00, 0x7f, 0xff, 0xfc, 0x0f, 0xff, 0xff, 0x80, 0x00, 0x00, 0x00,
        0xff, 0xff, 0xff, 0x0f, 0xff, 0xff, 0x80, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xcf, 0xff,
        0xff, 0x80, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xef, 0xff, 0xff, 0x80, 0x00, 0x00, 0x00,
        0x7f, 0xff, 0xff, 0xf7, 0xff, 0xff, 0x80, 0x00, 0x00, 0x00, 0x3f, 0xff, 0xff, 0xff, 0xfb,
        0xff, 0x00, 0x00, 0x00, 0x00, 0x3f, 0xff, 0xff, 0xff, 0xf1, 0xff, 0x3f, 0xf0, 0x00, 0x00,
        0x1f, 0xff, 0xff, 0xff, 0xf1, 0xfe, 0xff, 0xfe, 0x00, 0x00, 0x0f, 0xff, 0xff, 0xff, 0xf1,
        0xff, 0xff, 0xff, 0xc0, 0x00, 0x0f, 0xff, 0xff, 0xff, 0xe1, 0xff, 0xff, 0xff, 0xf8, 0x00,
        0x07, 0xff, 0xff, 0xff, 0xe1, 0xff, 0xff, 0xff, 0xff, 0x00, 0x03, 0xff, 0xff, 0xff, 0xe1,
        0xff, 0xff, 0xff, 0xff, 0xc0, 0x01, 0xff, 0xff, 0x3f, 0xe1, 0xff, 0xff, 0xff, 0xff, 0xe0,
        0x01, 0xff, 0xfe, 0x07, 0xe3, 0xff, 0xff, 0xff, 0xff, 0xe0, 0x00, 0xff, 0xff, 0x03, 0xe3,
        0xff, 0xff, 0xff, 0xff, 0xe0, 0x00, 0x7f, 0xff, 0x00, 0xf7, 0xff, 0xff, 0xff, 0xff, 0xc0,
        0x00, 0x3f, 0xff, 0xc0, 0xff, 0xc0, 0x7f, 0xff, 0xff, 0x80, 0x00, 0x1f, 0xff, 0xf0, 0xff,
        0x00, 0x3f, 0xff, 0xff, 0x00, 0x00, 0x0f, 0xff, 0xff, 0xff, 0x00, 0x7f, 0xff, 0xfc, 0x00,
        0x00, 0x07, 0xff, 0xff, 0xff, 0x01, 0xff, 0xff, 0xf8, 0x00, 0x00, 0x01, 0xff, 0xff, 0xff,
        0xff, 0xff, 0xff, 0xf0, 0x00, 0x00, 0x00, 0x7f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xc0, 0x00,
        0x00, 0x00, 0x1f, 0xfc, 0x7f, 0xff, 0xff, 0xff, 0x80, 0x00, 0x00, 0x00, 0x7f, 0xf8, 0x78,
        0xff, 0xff, 0xfe, 0x00, 0x00, 0x00, 0x00, 0xff, 0xf0, 0x78, 0x7f, 0xff, 0xfc, 0x00, 0x00,
        0x00, 0x01, 0xff, 0xe0, 0xf8, 0x7f, 0xff, 0xf0, 0x00, 0x00, 0x00, 0x03, 0xff, 0xc0, 0xf8,
        0x3f, 0xdf, 0xc0, 0x00, 0x00, 0x00, 0x07, 0xff, 0xc1, 0xfc, 0x3f, 0xe0, 0x00, 0x00, 0x00,
        0x00, 0x07, 0xff, 0x87, 0xfc, 0x1f, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xff, 0xcf, 0xfe,
        0x1f, 0xf8, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xff, 0xff, 0xff, 0x1f, 0xf8, 0x00, 0x00, 0x00,
        0x00, 0x1f, 0xff, 0xff, 0xff, 0x1f, 0xfc, 0x00, 0x00, 0x00, 0x00, 0x1f, 0xff, 0xff, 0xff,
        0xff, 0xfc, 0x00, 0x00, 0x00, 0x00, 0x1f, 0xff, 0xff, 0xff, 0xff, 0xfe, 0x00, 0x00, 0x00,
        0x00, 0x3f, 0xff, 0xff, 0xff, 0xff, 0xfe, 0x00, 0x00, 0x00, 0x00, 0x3f, 0xff, 0xff, 0xff,
        0xff, 0xfe, 0x00, 0x00, 0x00, 0x00, 0x3f, 0xff, 0xff, 0x3f, 0xff, 0xfe, 0x00, 0x00, 0x00,
        0x00, 0x7f, 0xff, 0xff, 0x3f, 0xff, 0xfe, 0x00, 0x00, 0x00, 0x00, 0x7f, 0xff, 0xff, 0x3f,
        0xff, 0xfe, 0x00, 0x00, 0x00, 0x00, 0x7f, 0xff, 0xfe, 0x3f, 0xff, 0xfe, 0x00, 0x00, 0x00,
        0x00, 0xff, 0xff, 0xfc, 0x1f, 0xff, 0xfe, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xf8, 0x1f,
        0xff, 0xfe, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xe0, 0x0f, 0xff, 0xfe, 0x00, 0x00, 0x00,
        0x01, 0xff, 0xff, 0x80, 0x07, 0xff, 0xfe, 0x00, 0x00, 0x00, 0x01, 0xff, 0xfc, 0x00, 0x03,
        0xff, 0xfe, 0x00, 0x00, 0x00, 0x01, 0xff, 0xe0, 0x00, 0x01, 0xff, 0xfe, 0x00, 0x00, 0x00,
        0x01, 0xff, 0x00, 0x00, 0x00, 0xff, 0xfe, 0x00, 0x00, 0x00, 0x00, 0xf8, 0x00, 0x00, 0x00,
        0x7f, 0xfe, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1f, 0xfe, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xfe, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x07, 0xfe, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xfe, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xfe, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x7e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1c, 0x00, 0x00, 0x00,
    ];

    printer.print_bitmap(80, 75, &adalogo).unwrap();

    // printer.print_bitmap(31, 100, &[0xff; 5 * 100]).unwrap();
    // printer.print_bitmap(33, 100, &[0xff; 5 * 100]).unwrap();
    // printer.print_bitmap(7, 100, &[0xff; 100 * 100]).unwrap();
    // printer.print_bitmap(31, 100, &[0xff; 5 * 100]).unwrap();
    // printer.print_bitmap(33, 100, &[0xff; 5 * 100]).unwrap();
    // for _ in 0..10 {
    // }
}
